---
title: "Problem set 2"
date: ""
format:
  html:
    toc: true
    number-sections: true
---

[Download source](https://raw.githubusercontent.com/ywanglab/STAT3000/refs/heads/main/psets/hw2.qmd)

For these exercises, do **not** load any packages other than **dslabs**.

Make sure to use **vectorization** whenever possible (avoid loops unless explicitly allowed).

```{r}
library(dslabs)
```

## 

What is the sum of the first 150 positive integers? Use the functions `seq` and `sum` to compute the sum with R for any `n`.

```{r}
# Your code here
```

## 

Load the `murders` dataset from **dslabs**. Use the function `str` to examine the structure of the `murders` object.

* What are the column names used by the data frame for these five variables: state name, abbreviation, region, population, total murders?
* Show the subset of `murders` showing states with **less than 1.2 per 100,000** deaths.
* Show **all** variables.

```{r}
str(murders)
```

```{r}
# Your code here
```

## 

Show the subset of `murders` showing states with **less than 1.2 per 100,000** deaths and in the **Northeast** of the US. Do **not** show the `region` variable.

```{r}
# Your code here
```

## 

Among states with a murder rate less than 1.2 per 100,000, show the **smallest population** state (show the state name, population, and rate).

```{r}
# Your code here
```

## 

Show the state with a population of **more than 8 million** with the **lowest** murder rate (show the state name, population, and rate).

```{r}
# Your code here
```

## 

Compute the murder rate for each **region** of the US (total murders divided by total population times 100,000). Return a data frame with one row per region and columns `region` and `rate`.

```{r}
# Your code here
```

## 

Create a vector of numbers that starts at 5, does not pass 60, and adds numbers in increments of 3/8:
5, 5 + 3/8, 5 + 6/8, and so on.

How many numbers does the list have? Hint: use `seq` and `length`.

```{r}
# Your code here
```

## 

Make this data frame:

```{r}
temp_f <- c(72, 95, 41, 86, 78, 33)
city <- c("Chicago", "Lagos", "Oslo", "Rio de Janeiro", 
          "San Juan", "Toronto")
city_temps <- data.frame(name = city, temperature_f = temp_f)
city_temps
```

Add a new column called `temperature_c` containing the temperatures in Celsius. Keep all existing columns.

```{r}
# Your code here
```

## 

Write a function `euler2` that computes the following sum for any `n`:

$$
S_n = 1 + \frac{1}{2^2} + \frac{1}{3^2} + \dots + \frac{1}{n^2}.
$$

Your function should:

* take a single input `n`
* return a single number

Test your function at `n = 10` and `n = 100`.

```{r}
# Your code here
```

## 

Show that as $n$ gets bigger, $S_n$ gets closer to $\pi^2/6$ by plotting $S_n$ versus $n$ for $n = 1,2,\dots,2000$ with a horizontal **dashed** line at $\pi^2/6$.

Hints:

* Create a vector `n <- 1:2000`
* Use `sapply(n, euler2)` (vectorization through apply is fine)
* Use `abline(h = ..., lty = 2)`

```{r}
# Your code here
```

## 

Use the `%in%` operator and the predefined object `state.abb` to create a logical vector that answers the question: which of the following are actual abbreviations?

**AL, AK, AZ, AR, AA**

```{r}
# Your code here
```

## 

Extend the code you used in the previous exercise to report the one entry that is **not** an actual abbreviation.

Hint: use `!` then `which` to obtain an index.

```{r}
# Your code here
```

## 

In the `murders` dataset, use `%in%` to show **all variables** for **Florida**, **California**, and **New York**, in that order.

```{r}
# Your code here
```

## 

Write a function called `vander_helper` that for any `x` and `n`, returns the vector:

$$
(1, x, x^2, x^3, \dots, x^n).
$$

Show the results for `x = 2` and `n = 6`.

Restrictions:

* Do not use a loop.
* Use vectorization (e.g., `^` with `0:n`).

```{r}
# Your code here
```

## 

Create a vector using:

```{r}
n <- 20000
p <- 0.35
set.seed(2025-9-18)
x <- sample(c(0,1), n, prob = c(1 - p, p), replace = TRUE)
```

Compute the length of each **stretch of consecutive 1s** (run lengths of 1s) and then plot the distribution of these values.

* Do **not** use a loop.
* Hint: use `rle(x)`.

Then compare the empirical proportions to a geometric distribution prediction by printing a small table for run lengths 1 through 8.

```{r}
# Your code here
```

## 

In the `murders` dataset:

1. Compute the national average murder rate (total murders / total population * 100,000).
2. Create a logical vector indicating which states have **both** a murder rate higher than the national average **and** population greater than 6 million.
3. Use `ifelse` to create a character vector labeling states:

   * `"High Crime, High Pop"` if rate > national average and pop > 6 million
   * `"High Crime, Low Pop"` if rate > national average and pop ≤ 6 million
   * `"Lower Crime"` otherwise

Finally, create a table of counts of these labels with `table()`.

```{r}
# Your code here
```

## 

Use `order`, `rank`, and `sort` functions on the murder rates to answer the following:

What is the murder rate of the state that ranks **12th** in terms of murder rate (from highest to lowest)?

Show your work by:

1. creating a murder rate vector called `rate`
2. using the appropriate function(s) to find the 12th ranked value

```{r}
# Your code here
```

## 

Write a function called `compute_harmonic_mean` that takes a numeric vector and returns the harmonic mean:

$$
\frac{n}{\sum_{i=1}^n \frac{1}{x_i}}.
$$

The function should return `NA` if **any** values are zero or negative.

Test your function on the vector `c(1, 2, 4, 8)` and show that it returns approximately `2.133333`.

```{r}
# Your code here
```

## 

Create a function called `safe_divide` that takes two arguments `x` and `y` and returns their ratio `x/y`, but returns the string `"Cannot divide by zero"` when `y` is zero.

Use vectorization so that the function works element-wise on vectors.

Test it on:

```r
x <- c(10, 20, 30)
y <- c(2, 0, 5)
```

```{r}
# Your code here
```

## 

Using the `murders` dataset, write a function called `classify_state_safety` that takes a state name as input and returns a classification based on the murder rate:

* `"Very Safe"` if rate < 1
* `"Safe"` if 1 ≤ rate < 3
* `"Moderate"` if 3 ≤ rate < 5
* `"High Risk"` if rate ≥ 5

If the state name is not found, return `"State not found"`.

Test your function on:

* `"Vermont"`
* `"Texas"`
* `"California"`
* `"NotAState"`

Then use `sapply` to classify all states and create a table showing how many states fall into each safety category using `table()`.

```{r}
# Your code here
```

